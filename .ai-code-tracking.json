{
  "version": "1.0",
  "records": [
    {
      "filePath": "C:/Users/stev1/OneDrive/Escritorio/proyect-ing-3/src/test/java/com/example/demo/service/OrderServiceTest.java",
      "timestamp": 1763739121618,
      "startOffset": 0,
      "endOffset": 69,
      "codeContent": "package com.example.demo.service;\n\npublic class OrderServiceTest {\n}\n",
      "aiProbability": 90,
      "aiTool": "AI Assistant",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/stev1/OneDrive/Escritorio/proyect-ing-3/src/test/java/com/example/demo/service/OrderServiceTest.java",
      "timestamp": 1763739125729,
      "startOffset": 35,
      "endOffset": 3851,
      "codeContent": "import com.example.demo.model.Customer;\nimport com.example.demo.model.OrderEntity;\nimport com.example.demo.model.Product;\nimport com.example.demo.repository.CustomerRepository;\nimport com.example.demo.repository.OrderRepository;\nimport com.example.demo.repository.ProductRepository;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport org.junit.jupiter.api.extension.ExtendWith;\n\nimport java.util.Optional;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\nclass OrderServiceTest {\n\n    @Mock private OrderRepository orderRepository;\n    @Mock private ProductRepository productRepository;\n    @Mock private CustomerRepository customerRepository;\n\n    @InjectMocks private OrderService orderService;\n\n    private Customer customer;\n    private Product product;\n\n    @BeforeEach\n    void setUp() {\n        customer \u003d new Customer(\"John Doe\", \"john@example.com\");\n        product \u003d new Product(\"Laptop\", 1200.0, 10);\n    }\n\n    @Test\n    void shouldReturnAllOrders() {\n        when(orderRepository.findAll()).thenReturn(List.of(new OrderEntity()));\n\n        List\u003cOrderEntity\u003e result \u003d orderService.findAll();\n\n        assertEquals(1, result.size());\n        verify(orderRepository).findAll();\n    }\n\n    @Test\n    void shouldFindOrderById() {\n        OrderEntity order \u003d new OrderEntity(customer, product, 2);\n        when(orderRepository.findById(1L)).thenReturn(Optional.of(order));\n\n        OrderEntity result \u003d orderService.findById(1L);\n\n        assertEquals(order, result);\n    }\n\n    @Test\n    void shouldThrowWhenOrderNotFound() {\n        when(orderRepository.findById(1L)).thenReturn(Optional.empty());\n\n        assertThrows(RuntimeException.class, () -\u003e orderService.findById(1L));\n    }\n\n    @Test\n    void shouldCreateOrderSuccessfully() {\n        long customerId \u003d 1L;\n        long productId \u003d 2L;\n        int quantity \u003d 3;\n\n        when(customerRepository.findById(customerId)).thenReturn(Optional.of(customer));\n        when(productRepository.findById(productId)).thenReturn(Optional.of(product));\n        when(orderRepository.countByCustomer(customer)).thenReturn(2L);\n        when(orderRepository.save(any(OrderEntity.class))).thenAnswer(invocation -\u003e invocation.getArgument(0));\n\n        OrderEntity result \u003d orderService.create(customerId, productId, quantity);\n\n        assertNotNull(result);\n        assertEquals(quantity, result.getQuantity());\n        assertEquals(7, product.getStock()); // 10 - 3\n\n        verify(productRepository).save(product);\n        verify(orderRepository).save(result);\n    }\n\n    @Test\n    void shouldThrowIfQuantityInvalid() {\n        assertThrows(RuntimeException.class, () -\u003e\n            orderService.create(1L, 2L, 0)\n        );\n    }\n\n    @Test\n    void shouldThrowIfStockIsNotEnough() {\n        product.setStock(2);\n        when(customerRepository.findById(1L)).thenReturn(Optional.of(customer));\n        when(productRepository.findById(2L)).thenReturn(Optional.of(product));\n\n        assertThrows(RuntimeException.class, () -\u003e\n            orderService.create(1L, 2L, 3)\n        );\n    }\n\n    @Test\n    void shouldThrowIfCustomerHasMoreThanFiveOrders() {\n        when(customerRepository.findById(1L)).thenReturn(Optional.of(customer));\n        when(productRepository.findById(2L)).thenReturn(Optional.of(product));\n        when(orderRepository.countByCustomer(customer)).thenReturn(5L);\n\n        assertThrows(RuntimeException.class, () -\u003e\n            orderService.create(1L, 2L, 1)\n        );\n    }\n\n    @Test\n    void shouldDeleteOrder() {\n        orderService.delete(1L);\n        verify(orderRepository).deleteById(1L);\n    }",
      "aiProbability": 90,
      "aiTool": "AI Assistant",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 119
    },
    {
      "filePath": "C:/Users/stev1/OneDrive/Escritorio/proyect-ing-3/src/test/java/com/example/demo/service/CustomerServiceTest.java",
      "timestamp": 1763739377594,
      "startOffset": 0,
      "endOffset": 72,
      "codeContent": "package com.example.demo.service;\n\npublic class CustomerServiceTest {\n}\n",
      "aiProbability": 90,
      "aiTool": "AI Assistant",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/stev1/OneDrive/Escritorio/proyect-ing-3/src/test/java/com/example/demo/service/CustomerServiceTest.java",
      "timestamp": 1763739384825,
      "startOffset": 35,
      "endOffset": 3532,
      "codeContent": "import com.example.demo.model.Customer;\nimport com.example.demo.repository.CustomerRepository;\nimport com.example.demo.repository.OrderRepository;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport org.junit.jupiter.api.extension.ExtendWith;\n\nimport java.util.Optional;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\nclass CustomerServiceTest {\n\n    @Mock\n    private CustomerRepository customerRepository;\n    \n    @Mock\n    private OrderRepository orderRepository;\n\n    @InjectMocks\n    private CustomerService customerService;\n\n    private Customer customer;\n\n    @BeforeEach\n    void setup() {\n        customer \u003d new Customer(\"John Doe\", \"john@example.com\");\n    }\n\n    @Test\n    void shouldReturnAllCustomers() {\n        when(customerRepository.findAll()).thenReturn(List.of(customer));\n\n        List\u003cCustomer\u003e result \u003d customerService.findAll();\n\n        assertEquals(1, result.size());\n        verify(customerRepository).findAll();\n    }\n\n    @Test\n    void shouldFindCustomerById() {\n        when(customerRepository.findById(1L)).thenReturn(Optional.of(customer));\n\n        Optional\u003cCustomer\u003e result \u003d customerService.findById(1L);\n\n        assertTrue(result.isPresent());\n        assertEquals(customer, result.get());\n    }\n\n    @Test\n    void shouldCreateCustomerSuccessfully() {\n        when(customerRepository.save(customer)).thenReturn(customer);\n\n        Customer result \u003d customerService.create(customer);\n\n        assertEquals(customer, result);\n        verify(customerRepository).save(customer);\n    }\n\n    @Test\n    void shouldUpdateCustomerSuccessfully() {\n        Customer updated \u003d new Customer(\"New Name\", \"new@example.com\");\n\n        when(customerRepository.findById(1L)).thenReturn(Optional.of(customer));\n        when(customerRepository.save(any(Customer.class))).thenAnswer(invocation -\u003e invocation.getArgument(0));\n\n        Customer result \u003d customerService.update(1L, updated);\n\n        assertEquals(\"New Name\", result.getName());\n        assertEquals(\"new@example.com\", result.getEmail());\n        verify(customerRepository).save(customer);\n    }\n\n    @Test\n    void shouldThrowWhenCustomerNotFoundForUpdate() {\n        when(customerRepository.findById(1L)).thenReturn(Optional.empty());\n\n        assertThrows(RuntimeException.class,\n                () -\u003e customerService.update(1L, new Customer()));\n    }\n\n    @Test\n    void shouldDeleteCustomerSuccessfully() {\n        when(customerRepository.findById(1L)).thenReturn(Optional.of(customer));\n        when(orderRepository.countByCustomer(customer)).thenReturn(0L);\n\n        customerService.delete(1L);\n\n        verify(customerRepository).deleteById(1L);\n    }\n\n    @Test\n    void shouldThrowWhenDeletingCustomerWithOrders() {\n        when(customerRepository.findById(1L)).thenReturn(Optional.of(customer));\n        when(orderRepository.countByCustomer(customer)).thenReturn(3L);\n\n        assertThrows(RuntimeException.class,\n                () -\u003e customerService.delete(1L));\n\n        verify(customerRepository, never()).deleteById(any());\n    }\n\n    @Test\n    void shouldThrowWhenDeletingNonExistingCustomer() {\n        when(customerRepository.findById(1L)).thenReturn(Optional.empty());\n\n        assertThrows(RuntimeException.class, () -\u003e customerService.delete(1L));\n    }",
      "aiProbability": 90,
      "aiTool": "AI Assistant",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 114
    },
    {
      "filePath": "C:/Users/stev1/OneDrive/Escritorio/proyect-ing-3/src/test/java/com/example/demo/service/CategoryServiceTest.java",
      "timestamp": 1763739435876,
      "startOffset": 0,
      "endOffset": 72,
      "codeContent": "package com.example.demo.service;\n\npublic class CategoryServiceTest {\n}\n",
      "aiProbability": 90,
      "aiTool": "AI Assistant",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 5
    },
    {
      "filePath": "C:/Users/stev1/OneDrive/Escritorio/proyect-ing-3/src/test/java/com/example/demo/service/CategoryServiceTest.java",
      "timestamp": 1763739444095,
      "startOffset": 35,
      "endOffset": 2533,
      "codeContent": "import com.example.demo.model.Category;\nimport com.example.demo.repository.CategoryRepository;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport org.junit.jupiter.api.extension.ExtendWith;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\nclass CategoryServiceTest {\n\n    @Mock\n    private CategoryRepository categoryRepository;\n\n    @InjectMocks\n    private CategoryService categoryService;\n\n    private Category category;\n\n    @BeforeEach\n    void setup() {\n        category \u003d new Category(\"Electronics\");\n    }\n\n    @Test\n    void shouldReturnAllCategories() {\n        when(categoryRepository.findAll()).thenReturn(List.of(category));\n\n        List\u003cCategory\u003e result \u003d categoryService.findAll();\n\n        assertEquals(1, result.size());\n        verify(categoryRepository).findAll();\n    }\n\n    @Test\n    void shouldReturnCategoryById() {\n        when(categoryRepository.findById(1L)).thenReturn(Optional.of(category));\n\n        Optional\u003cCategory\u003e result \u003d categoryService.findById(1L);\n\n        assertTrue(result.isPresent());\n        assertEquals(category, result.get());\n    }\n\n    @Test\n    void shouldCreateCategorySuccessfully() {\n        when(categoryRepository.save(category)).thenReturn(category);\n\n        Category result \u003d categoryService.create(category);\n\n        assertEquals(category, result);\n        verify(categoryRepository).save(category);\n    }\n\n    @Test\n    void shouldUpdateCategorySuccessfully() {\n        Category updated \u003d new Category(\"New Name\");\n\n        when(categoryRepository.findById(1L)).thenReturn(Optional.of(category));\n        when(categoryRepository.save(any(Category.class))).thenAnswer(i -\u003e i.getArgument(0));\n\n        Category result \u003d categoryService.update(1L, updated);\n\n        assertEquals(\"New Name\", result.getName());\n        verify(categoryRepository).save(category);\n    }\n\n    @Test\n    void shouldThrowWhenUpdatingNonExistingCategory() {\n        when(categoryRepository.findById(1L)).thenReturn(Optional.empty());\n\n        assertThrows(RuntimeException.class,\n                () -\u003e categoryService.update(1L, new Category()));\n    }\n\n    @Test\n    void shouldDeleteSuccessfully() {\n        categoryService.delete(1L);\n\n        verify(categoryRepository).deleteById(1L);\n    }",
      "aiProbability": 90,
      "aiTool": "AI Assistant",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 88
    },
    {
      "filePath": "C:/Users/stev1/OneDrive/Escritorio/proyect-ing-3/src/test/java/com/example/demo/service/ProductServiceTest.java",
      "timestamp": 1763740369232,
      "startOffset": 703,
      "endOffset": 5313,
      "codeContent": "// Simula lista de productos en base de datos\n        when(productRepository.findAll()).thenReturn(List.of(\n                new Product(\"A\", 10, 1),\n                new Product(\"B\", 20, 2)\n        ));\n\n        // Ejecuta servicio\n        List\u003cProduct\u003e result \u003d service.findAll();\n\n        // Verifica resultados y llamada al repositorio\n        assertEquals(2, result.size());\n        verify(productRepository).findAll();\n    }\n\n    @Test\n    void findById_ShouldReturnProduct_WhenExists() {\n        // Creamos un producto simulado\n        Product product \u003d new Product(\"Phone\", 500.0, 10);\n        product.setId(1L);\n\n        // Simulamos búsqueda por ID\n        when(productRepository.findById(1L)).thenReturn(Optional.of(product));\n\n        Optional\u003cProduct\u003e result \u003d service.findById(1L);\n\n        // Validaciones de retorno\n        assertTrue(result.isPresent());\n        assertEquals(\"Phone\", result.get().getName());\n        verify(productRepository).findById(1L);\n    }\n\n    @Test\n    void create_ShouldSaveProduct_WhenValid() {\n        // Producto correcto para guardar\n        Product product \u003d new Product(\"Laptop\", 1000.0, 5);\n\n        // Simula que el nombre no existe previamente\n        when(productRepository.findByName(\"Laptop\")).thenReturn(Optional.empty());\n        when(productRepository.save(product)).thenReturn(product);\n\n        Product result \u003d service.create(product);\n\n        assertEquals(\"Laptop\", result.getName());\n        verify(productRepository).findByName(\"Laptop\");\n        verify(productRepository).save(product);\n    }\n\n    @Test\n    void create_ShouldThrowException_WhenPriceIsInvalid() {\n        // Producto con precio inválido\n        Product product \u003d new Product(\"Laptop\", 0.0, 5);\n\n        // Valida que se lance excepción por precio no válido\n        RuntimeException ex \u003d assertThrows(RuntimeException.class,\n                () -\u003e service.create(product));\n\n        assertEquals(\"Product price must be positive\", ex.getMessage());\n        verify(productRepository, never()).save(any());\n    }\n\n    @Test\n    void create_ShouldThrowException_WhenNameExists() {\n        // Simula producto ya existente con ese nombre\n        Product existing \u003d new Product(\"Laptop\", 900.0, 5);\n        when(productRepository.findByName(\"Laptop\")).thenReturn(Optional.of(existing));\n\n        // Verifica que se lance excepción por nombre duplicado\n        RuntimeException ex \u003d assertThrows(RuntimeException.class,\n                () -\u003e service.create(existing));\n\n        assertEquals(\"Product name must be unique\", ex.getMessage());\n        verify(productRepository, never()).save(any());\n    }\n\n    @Test\n    void update_ShouldModifyAndSaveProduct_WhenValid() {\n        // Producto existente\n        Product existing \u003d new Product(\"Old\", 200.0, 2);\n        existing.setId(1L);\n\n        // Datos actualizados\n        Product updated \u003d new Product(\"New\", 300.0, 3);\n\n        when(productRepository.findById(1L)).thenReturn(Optional.of(existing));\n        when(productRepository.save(existing)).thenReturn(existing);\n\n        Product result \u003d service.update(1L, updated);\n\n        // Valida propiedades actualizadas\n        assertEquals(\"New\", result.getName());\n        assertEquals(300.0, result.getPrice());\n        assertEquals(3, result.getStock());\n        verify(productRepository).save(existing);\n    }\n\n    @Test\n    void update_ShouldThrowException_WhenProductNotFound() {\n        // No encuentra el producto\n        when(productRepository.findById(1L)).thenReturn(Optional.empty());\n\n        RuntimeException ex \u003d assertThrows(RuntimeException.class,\n                () -\u003e service.update(1L, new Product(\"Test\", 50.0, 1)));\n\n        assertEquals(\"Product not found\", ex.getMessage());\n    }\n\n    @Test\n    void update_ShouldThrowException_WhenPriceInvalid() {\n        // Producto encontrado\n        Product existing \u003d new Product(\"Phone\", 500.0, 10);\n        existing.setId(1L);\n\n        // Producto actualizado con precio inválido\n        Product updated \u003d new Product(\"PhoneX\", 0.0, 5);\n\n        when(productRepository.findById(1L)).thenReturn(Optional.of(existing));\n\n        RuntimeException ex \u003d assertThrows(RuntimeException.class,\n                () -\u003e service.update(1L, updated));\n\n        assertEquals(\"Product price must be positive\", ex.getMessage());\n        verify(productRepository, never()).save(any());\n    }\n\n    @Test\n    void delete_ShouldDeleteProductById() {\n        // Simula que el repositorio borra correctamente\n        doNothing().when(productRepository).deleteById(1L);\n\n        service.delete(1L);\n\n        // Valida que se llamó al repositorio",
      "aiProbability": 95,
      "aiTool": "AI Assistant",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 132
    },
    {
      "filePath": "C:/Users/stev1/OneDrive/Escritorio/proyect-ing-3/src/test/java/com/example/demo/service/OrderServiceTest.java",
      "timestamp": 1763740726318,
      "startOffset": 1076,
      "endOffset": 4725,
      "codeContent": "// Crear datos base para las pruebas\n        customer \u003d new Customer(\"John Doe\", \"john@example.com\");\n        product \u003d new Product(\"Laptop\", 1200.0, 10);\n    }\n\n    @Test\n    void shouldReturnAllOrders() {\n        // Simular una lista con una orden en base de datos\n        when(orderRepository.findAll()).thenReturn(List.of(new OrderEntity()));\n\n        // Ejecutar servicio\n        List\u003cOrderEntity\u003e result \u003d orderService.findAll();\n\n        // Validar resultado y que el repositorio fue llamado\n        assertEquals(1, result.size());\n        verify(orderRepository).findAll();\n    }\n\n    @Test\n    void shouldFindOrderById() {\n        // Simular una orden existente\n        OrderEntity order \u003d new OrderEntity(customer, product, 2);\n        when(orderRepository.findById(1L)).thenReturn(Optional.of(order));\n\n        // Ejecutar servicio\n        OrderEntity result \u003d orderService.findById(1L);\n\n        // Validar que se obtuvo la orden esperada\n        assertEquals(order, result);\n    }\n\n    @Test\n    void shouldThrowWhenOrderNotFound() {\n        // Simular que no existe la orden buscada\n        when(orderRepository.findById(1L)).thenReturn(Optional.empty());\n\n        // Validar excepción esperada\n        assertThrows(RuntimeException.class, () -\u003e orderService.findById(1L));\n    }\n\n    @Test\n    void shouldCreateOrderSuccessfully() {\n        long customerId \u003d 1L;\n        long productId \u003d 2L;\n        int quantity \u003d 3;\n\n        // Simular entidades válidas encontradas\n        when(customerRepository.findById(customerId)).thenReturn(Optional.of(customer));\n        when(productRepository.findById(productId)).thenReturn(Optional.of(product));\n        when(orderRepository.countByCustomer(customer)).thenReturn(2L);\n\n        // Simular guardado de orden\n        when(orderRepository.save(any(OrderEntity.class)))\n                .thenAnswer(invocation -\u003e invocation.getArgument(0));\n\n        // Ejecutar servicio\n        OrderEntity result \u003d orderService.create(customerId, productId, quantity);\n\n        // Validaciones de negocio: stock reducido correctamente\n        assertNotNull(result);\n        assertEquals(quantity, result.getQuantity());\n        assertEquals(7, product.getStock()); // 10 - 3\n\n        // Verificar persistencias\n        verify(productRepository).save(product);\n        verify(orderRepository).save(result);\n    }\n\n    @Test\n    void shouldThrowIfQuantityInvalid() {\n        // Validar que una cantidad no positiva lanza excepción\n        assertThrows(RuntimeException.class,\n                () -\u003e orderService.create(1L, 2L, 0));\n    }\n\n    @Test\n    void shouldThrowIfStockIsNotEnough() {\n        product.setStock(2);\n\n        // Simular repositorios\n        when(customerRepository.findById(1L)).thenReturn(Optional.of(customer));\n        when(productRepository.findById(2L)).thenReturn(Optional.of(product));\n\n        // Stock insuficiente debe provocar error\n        assertThrows(RuntimeException.class,\n                () -\u003e orderService.create(1L, 2L, 3));\n    }\n\n    @Test\n    void shouldThrowIfCustomerHasMoreThanFiveOrders() {\n        // Simular límite de órdenes alcanzado\n        when(customerRepository.findById(1L)).thenReturn(Optional.of(customer));\n        when(productRepository.findById(2L)).thenReturn(Optional.of(product));\n        when(orderRepository.countByCustomer(customer)).thenReturn(5L);\n\n        // Regla de negocio debe lanzar excepción\n        assertThrows(RuntimeException.class,\n                () -\u003e orderService.create(1L, 2L, 1));\n    }\n\n    @Test\n    void shouldDeleteOrder() {\n        // Ejecutar servicio\n        orderService.delete(1L);\n\n        // Verificar eliminación",
      "aiProbability": 95,
      "aiTool": "AI Assistant",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 106
    },
    {
      "filePath": "C:/Users/stev1/OneDrive/Escritorio/proyect-ing-3/src/test/java/com/example/demo/service/CustomerServiceTest.java",
      "timestamp": 1763740966484,
      "startOffset": 878,
      "endOffset": 4369,
      "codeContent": "// Se inicializa un cliente base para todas las pruebas\n        customer \u003d new Customer(\"John Doe\", \"john@example.com\");\n    }\n\n    @Test\n    void shouldReturnAllCustomers() {\n        // Prueba que el servicio retorne correctamente la lista de todos los clientes\n        when(customerRepository.findAll()).thenReturn(List.of(customer));\n\n        List\u003cCustomer\u003e result \u003d customerService.findAll();\n\n        assertEquals(1, result.size()); // Debe haber exactamente un cliente\n        verify(customerRepository).findAll(); // Verifica que se llamo al repositorio\n    }\n\n    @Test\n    void shouldFindCustomerById() {\n        // Verifica que se obtenga un cliente existente por su ID\n        when(customerRepository.findById(1L)).thenReturn(Optional.of(customer));\n\n        Optional\u003cCustomer\u003e result \u003d customerService.findById(1L);\n\n        assertTrue(result.isPresent()); // El resultado no debe estar vacío\n        assertEquals(customer, result.get()); // El cliente retornado es el esperado\n    }\n\n    @Test\n    void shouldCreateCustomerSuccessfully() {\n        // Prueba la creación de un cliente, validando que se guarde correctamente\n        when(customerRepository.save(customer)).thenReturn(customer);\n\n        Customer result \u003d customerService.create(customer);\n\n        assertEquals(customer, result);\n        verify(customerRepository).save(customer);\n    }\n\n    @Test\n    void shouldUpdateCustomerSuccessfully() {\n        // Prueba la actualización correcta de un cliente existente\n        // con nuevos valores en su información\n        Customer updated \u003d new Customer(\"New Name\", \"new@example.com\");\n\n        when(customerRepository.findById(1L)).thenReturn(Optional.of(customer));\n        when(customerRepository.save(any(Customer.class))).thenAnswer(invocation -\u003e invocation.getArgument(0));\n\n        Customer result \u003d customerService.update(1L, updated);\n\n        // Verifica que los valores del cliente se hayan actualizado\n        assertEquals(\"New Name\", result.getName());\n        assertEquals(\"new@example.com\", result.getEmail());\n\n        verify(customerRepository).save(customer);\n    }\n\n    @Test\n    void shouldThrowWhenCustomerNotFoundForUpdate() {\n        // Si el cliente a actualizar no existe, se debe lanzar una excepción\n        when(customerRepository.findById(1L)).thenReturn(Optional.empty());\n\n        assertThrows(RuntimeException.class,\n                () -\u003e customerService.update(1L, new Customer()));\n    }\n\n    @Test\n    void shouldDeleteCustomerSuccessfully() {\n        // Prueba que un cliente sin órdenes pueda ser eliminado\n        when(customerRepository.findById(1L)).thenReturn(Optional.of(customer));\n        when(orderRepository.countByCustomer(customer)).thenReturn(0L);\n\n        customerService.delete(1L);\n\n        verify(customerRepository).deleteById(1L);\n    }\n\n    @Test\n    void shouldThrowWhenDeletingCustomerWithOrders() {\n        // Si el cliente tiene órdenes asociadas, no debe permitirse su eliminación\n        when(customerRepository.findById(1L)).thenReturn(Optional.of(customer));\n        when(orderRepository.countByCustomer(customer)).thenReturn(3L);\n\n        assertThrows(RuntimeException.class,\n                () -\u003e customerService.delete(1L));\n\n        // Se verifica que nunca se intente eliminar\n        verify(customerRepository, never()).deleteById(any());\n    }\n\n    @Test\n    void shouldThrowWhenDeletingNonExistingCustomer() {\n        // Si el cliente no existe al intentar eliminar, se debe lanzar una excepción",
      "aiProbability": 95,
      "aiTool": "AI Assistant",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 91
    },
    {
      "filePath": "C:/Users/stev1/OneDrive/Escritorio/proyect-ing-3/src/test/java/com/example/demo/service/CategoryServiceTest.java",
      "timestamp": 1763741022295,
      "startOffset": 770,
      "endOffset": 3336,
      "codeContent": "// Se inicializa una categoría para ser utilizada en las pruebas\n        category \u003d new Category(\"Electronics\");\n    }\n\n    @Test\n    void shouldReturnAllCategories() {\n        // Prueba que el servicio devuelva todas las categorías disponibles\n        when(categoryRepository.findAll()).thenReturn(List.of(category));\n\n        List\u003cCategory\u003e result \u003d categoryService.findAll();\n\n        // Verifica que la lista tenga exactamente un elemento y que se llamara al repositorio\n        assertEquals(1, result.size());\n        verify(categoryRepository).findAll();\n    }\n\n    @Test\n    void shouldReturnCategoryById() {\n        // Prueba que se obtenga una categoría correctamente mediante su ID\n        when(categoryRepository.findById(1L)).thenReturn(Optional.of(category));\n\n        Optional\u003cCategory\u003e result \u003d categoryService.findById(1L);\n\n        // Se verifica que la categoría exista y sea la misma simulada\n        assertTrue(result.isPresent());\n        assertEquals(category, result.get());\n    }\n\n    @Test\n    void shouldCreateCategorySuccessfully() {\n        // Prueba la creación de una nueva categoría\n        when(categoryRepository.save(category)).thenReturn(category);\n\n        Category result \u003d categoryService.create(category);\n\n        // Verifica que la categoría fue guardada y retornada correctamente\n        assertEquals(category, result);\n        verify(categoryRepository).save(category);\n    }\n\n    @Test\n    void shouldUpdateCategorySuccessfully() {\n        // Prueba la actualización de una categoría existente con nuevos datos\n        Category updated \u003d new Category(\"New Name\");\n\n        when(categoryRepository.findById(1L)).thenReturn(Optional.of(category));\n        // Se simula que el repositorio devuelve el objeto actualizado\n        when(categoryRepository.save(any(Category.class))).thenAnswer(i -\u003e i.getArgument(0));\n\n        Category result \u003d categoryService.update(1L, updated);\n\n        // Verificaciones sobre los nuevos valores aplicados\n        assertEquals(\"New Name\", result.getName());\n        verify(categoryRepository).save(category);\n    }\n\n    @Test\n    void shouldThrowWhenUpdatingNonExistingCategory() {\n        // Prueba que se lance excepción al intentar actualizar una categoría que no existe\n        when(categoryRepository.findById(1L)).thenReturn(Optional.empty());\n\n        assertThrows(RuntimeException.class,\n                () -\u003e categoryService.update(1L, new Category()));\n    }\n\n    @Test\n    void shouldDeleteSuccessfully() {\n        // Prueba que se llame al repositorio para eliminar una categoría",
      "aiProbability": 95,
      "aiTool": "AI Assistant",
      "detectionMethod": "REALTIME_SPEED_ANALYSIS",
      "lineCount": 68
    }
  ],
  "toolStats": {
    "AI Assistant": {
      "usageCount": 10,
      "totalLines": 733
    }
  }
}